{"meta":{"title":"hbzyin/blog","subtitle":"Front end developer.","description":"web 前端 | 切图仔 | javascript | css | hbzyin","author":"hbzyin","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"oAuth 认证机制","slug":"oAuth-md","date":"2017-09-09T07:31:39.000Z","updated":"2017-09-09T07:33:12.000Z","comments":true,"path":"2017/09/09/oAuth-md/","link":"","permalink":"http://yoursite.com/2017/09/09/oAuth-md/","excerpt":"","text":"这段时间公司开发项目用到oAuth2协议，现在做一下梳理。 CORS即Cross Origin Resouce Share，跨域资源共享；是W3C为防止脚本攻击，而制定的安全标准之一，它允许浏览器向跨域服务器发送XMLHttpRequest请求；跨域域问题，伴随而来的就是前端项目中的权限认证问题。 1. 基本逻辑： 跨域请求分为两种：简单请求、非简单请求，两种情景处理具体细节不同，但实现逻辑相同 1. 用户使用用户名、密码登录； 2. 后台校验用户信息； 3. 跳转至oAuth认证接口，返回token、refresh token、token expires;（此处token一般有有效期） 4. 用户携带token值与后台DB服务通过http/https交互； 5. token 值到期后；用户携带refresh token请求oAuth token刷新接口更新token并通过响应发送至客户； 6. 重复第4、第5步，保证token有效可用状态下，与后台进行交互 oAuth2的协议.里面有两个比较常用的接口.1. 获取token接口: /oauth/token? 参数: (grant_type是写规定好的,其它的两个自定义) grant_type=password username=development@sometech.com password=oQd-BfT-cer-7LP 完整的样例:http://localhost:9000/oauth/token?grant_type=password&amp;username=development@sometech.com&amp;password=oQd-BfT-cer-7LP 返回结果样例: 1234567&#123; &quot;access_token&quot;: &quot;beeaa54e-8391-4de0-8ba6-ce145b3fb812&quot;, &quot;token_type&quot;: &quot;bearer&quot;, &quot;refresh_token&quot;: &quot;8129769a-d804-46c7-856a-3bacd409b650&quot;, &quot;expires_in&quot;: 3599, &quot;scope&quot;: &quot;read write&quot;&#125; 2. 刷新token接口:http://localhost:9000/oauth/token? 参数:(refresh_token是根据1中的来定的.其它参数是固定的) client_id=dashboard client_secret=secret grant_type=refresh_token refresh_token=43dca105-627e-4f50-86e8-0c22c2f3abe9 样例: http://localhost:9000/oauth/token?client_id=dashboard&amp;client_secret=secret&amp;grant_type=refresh_token&amp;refresh_token=43dca105-627e-4f50-86e8-0c22c2f3abe9 返回结果1234567&#123; &quot;access_token&quot;: &quot;0135c92b-12ab-4af9-88f4-97ef85115e71&quot;, &quot;token_type&quot;: &quot;bearer&quot;, &quot;refresh_token&quot;: &quot;75d209b5-a30d-43a8-abcd-850e7fb62e76&quot;, &quot;expires_in&quot;: 3599, &quot;scope&quot;: &quot;read write&quot;&#125; 3. oAuth2仅仅是实现跨域请求的一种，还有其他多种方案，如jsonp、document.domain、window.name、window.postMessage、CSST(css text Transformation)、flash等。 –end","raw":null,"content":null,"categories":[],"tags":[{"name":"secrect","slug":"secrect","permalink":"http://yoursite.com/tags/secrect/"}]},{"title":"workflow--项目工作流程","slug":"git-workflow","date":"2017-09-09T06:13:33.000Z","updated":"2017-09-09T06:14:31.000Z","comments":true,"path":"2017/09/09/git-workflow/","link":"","permalink":"http://yoursite.com/2017/09/09/git-workflow/","excerpt":"","text":"&emsp;&emsp;在软件开发的过程中，项目团队必然会使用版本控制系统，比如CVS、SVN(集中式版本控制系统)、GIT(分布式版本控制系统)。版本控制系统选定后，紧接着为了提高团队的协同开发效率，就需要选择一种适合当前团队、或者适合当前项目的开发流程。这里以主流的git版本控制系统为例，介绍常见的3种工作流：①Git flow ②Github flow ③Gitlab Flow &emsp;&emsp;本文的三种工作流程，都属于功能驱动式开发(Featrue-driven development,简称FDD)范畴，FDD即项目开发的起点是需求，维护master主分支，切分出功能分支(feature branch)、补丁分支(hotfix branch);完成开发后，功能分支、补丁分支合并到主分支，同时被删除。 Git workflow 优点：流程清晰，版本清晰,理解简单 缺点：长期维护两个主分支，不便于持续发布；分支切换频繁 使用场景：定期发布，长期维护，如：游戏开发项目、底层服务程序 简介：维护2+3+个branch 长期维护2个分支master、develop分支 : master branch : 用于发布、生产部署，时刻保持最稳定生产版本，并标注版本号(Tag); develop branch : 用于日常开发维护，时刻存放最新开发版本，每次发开功能是从次分支拉出新的feature分支进行开发。 开发、发布维护3个临时分支，功能开发、部署完成之后便被删除 release branch : 用于正是发布前预发布，进行文档及版本元信息更新。合并到master分支完成正是发布后，便将该分支合更新并到develop分支，删除该分支； hotfix branch : 用于发布后紧急bug修复，或热修复，从master分支拉出。完成bug修复后便合并到master分支，同时将更新合并到develop分支，删除该分支； featureXXX branch : 用于新功能开发，当需要开发新功能时，从develop分支中拉出，用于开发新功能。开发完成后，便合并到develop分支并被删除； 3.Git workflow 具体工作流程图如下： Github workflow 优点：简单、适合频繁发布版本 缺点：版本概念模糊 使用场景：不定期持续发布、热发布，如：网站开发 简介：github.com 使用的工作流程、git flow精简版 长期维护1个分支； master branch : 用于发布、功能更新，时刻保持最新版本、稳定版本、随时可发布； 短期维护1+开发分支； featureXX branch : 用于开发新功能；从master分支拉出。功能开发完成后，向master分支发送pull request请求(简称PR)，合并请求被master branch允许后，该分支被删除； Github Flow工作流程示意图如下 Gitlab workflow 优点：兼容Git Flow 和Github Flow 两种模式 特点：上游优先 —— 只有上游分支采纳的版本变化，才会应用到其他分之； 简介： 持续发布模式 + 版本发布模式 持续发布模式 master branch : 开发环境分支，用于开发功能使用，是其他所有分支的上游分支。该分支更新的代码会向下应用到其他环境分支； pre-production branch : 预发环境分支，用于预发布测试，从master分支拉出，同时是production分支的上游。 production branch : 生产环境分支，用于生产发布，从pre-production分支拉出，是pre-production分支的下游。 featureX/fixX branch : 开发功能/修复bug分支，用于开发/修复bug,从master分支拉出，是master分支的上游。该分支开发完成后，先合并到mster分支，确认没有问题后；再cherry-pick到pre-production分支；pre-production分支也确认没有问题再cherry-pick到production分支。 版本发布模式 master branch : 开发环境分支，用于开发功能使用，是其他所有分支的上游分支。该分支更新的代码会向下应用到其他环境分支；Version-x branch : 发布版本分支，从master分支拉出，用于发布不同版本。featureX/fixX branch : 开发功能/修复bug分支，用于开发/修复bug,从master分支拉出，是master分支的上游。该分支开发完成后，先合并到mster分支，确认没有问题后；再cherry-pick到相对应的version-x分支。 两种工作模式的流程示意图 参考文章： 1.Git workflow 参考： git flow cheatsheet 、Git tower 2.Github workflow 参考：github guide 3.Gitlab workflow 参考：gitlab flow、gitlab workflow 4.版本控制系统入门介绍,参考： Subversion VS Git","raw":null,"content":null,"categories":[],"tags":[{"name":"workflow","slug":"workflow","permalink":"http://yoursite.com/tags/workflow/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"Ngx-bootstrap组件总结","slug":"web-component","date":"2017-09-09T05:20:33.000Z","updated":"2017-09-09T05:16:56.000Z","comments":true,"path":"2017/09/09/web-component/","link":"","permalink":"http://yoursite.com/2017/09/09/web-component/","excerpt":"","text":"前端开发会有一些常见的需求，比如输入表单、日期、下拉菜单、表格、提示、弹窗等等，一般项目开发周期都被公司产品、市场等各种因素影响，被不断的压缩。除了极个别的开发大神，以及一些框架开发者，极少出现会自己去从零开始写这些常见的组件。 而通常做法是引入一个成熟的插件/库来实现；Ngx-bootstrap便是可供选择的一个组件库，当然你也可以选择比如Prime-NG、material、material-ui等其他各种优秀的风格组件库，来做为你开发的工具。 本篇仅以ngx-bootstrap为例，介绍前端开发过程中一些常用的组件。 包括并不限于以下17种： 提示：tips——用于简短的缩写或特殊名词，用悬浮窗方式进行解释、备注。 弹窗：popover——点击后显示的隐藏导航、链接或注释。 消息条/警告：alerts——操作消息提示、或者系统消息列表提示。 模态框：modal——弹窗层对话框，一般用于有序步骤操作。 时间选择：timepicker——时间选择器，可针对具体到秒的时间选择，比如定时发送邮件等。 日期选择：datepicker——日期选择器，用于日期的选择，时间选择范围为年、月、日，可定制最大最小日期等。 下拉菜单：dropdowns——点击按钮弹出隐藏下拉菜单、导航或说明，菜单悬浮。 折叠面板：accordion——点击目标显示出隐藏内容，隐藏内容从属于文档流，会重新绘制dom; 标签页：tabs——点击标题菜单，切换不同的页面，用于分页显示同一类主题； 导航条：navBar——页面顶部或者侧边导航栏，用于页面主题内容的跳转控制、页面布局； 轮播图：carousel——图片轮播，一般用于多幅宣传图册的自动循环播放； 按钮：button——定制页面按钮的样式风格； 输入表单：imput——定制化页面的输入表单样式风格，用户可自定义； 表格：sortable——可排序内容，用于列表数据的排序用 分页：pagination——表格数据的分页展示控件，用于在优化页面展示效果，提升用户体验； 进度条:progressBar——一般用于数据加载、用户操作进度指示作用，提升用户页面交互体验； 具体效果图如下 carousel tips popover alertts modal timepicker datepicker pagination progressBar tabs rating –不定期更新中….","raw":null,"content":null,"categories":[],"tags":[{"name":"component","slug":"component","permalink":"http://yoursite.com/tags/component/"},{"name":"bootstrap","slug":"bootstrap","permalink":"http://yoursite.com/tags/bootstrap/"}]},{"title":"Front end","slug":"frontend-skills","date":"2017-09-09T05:20:33.000Z","updated":"2017-09-09T07:08:18.000Z","comments":true,"path":"2017/09/09/frontend-skills/","link":"","permalink":"http://yoursite.com/2017/09/09/frontend-skills/","excerpt":"","text":"1. 设计模式相关 响应式/函数式编程：Rxjs-Reactive extention for javascript 面向对象式编程： OOP -Object Oriented Programming 迭代器模式编程： Iterator Pattern（ES6中可迭代对象：Array、String、Map、Set、DOM data structures） 2. Back-end 序号 范围 名称 作用 使用场景 相关信息 1 数据库 mySQL 后台数据库 暂无 官网 2 数据库 php 数据库脚本 官网 3 数据库 Nodejs 数据库脚本 事件驱动、非阻塞I/O模型 官网 2.1 后端框架 序号 名 称 所属语言 模板引擎 相关技术 1 Laravel php blade 2 SpringMVC JAVA thymeleaf 3 Express Nodejs jade、ejs、handlerbar 热部署工具PM2、Forever、strongloopPM 4 KOA Nodejs KOA 、Express、Hapi三大框架对比 3. 前端构建工具 序号 类别 名称 作用(范围) star 特点 官网 1 JS包管理器 npm JavaScript包管理器 13,284+ 官网 2 JS包管理器 yarn JavaScript包管理器 26,461+ 官网 3 前端项目打包压缩 webpack 所有资源 30,423+ 官网 4 前端项目打包压缩 gulp js、css、html 26,924+ 官网 5 前端项目打包压缩 grunt js、css、html 11,508+ 官网 6 前端项目打包压缩 bower js、css、html 15,171+ 官网 7 前端项目打包压缩 browserify js、css、html 11,201+ 官网 4. Front-end4.1 前端框架 不同框架性能对比测试，传送门 序号 名称 团队 设计模式 star 包大小(gzip) 学习曲线 相关技术 相关信息 1 angularjs 谷歌 双向数据绑定 56,105+ 陡峭 MVC 官网 2 angular 谷歌 双向数据绑定 26,225+ 237.41kb/v4.1.3 陡峭 MVC、组件化、Rxjs 官网 3 react facebook 单向数据绑定 71,926+ 46.45kb/v15.5.4 适中 MVC、组件化、React+Flux+JSX状态存储 官网 4 vue.js 尤雨溪（国内个人) 双向数据绑定 61,363+ 28.90kb/v2.3.4 简单 MVC、组件化、 官网 5 Polymer 谷歌赞助 17,815+ 129.89kb/v2.13.3 组件化，类似vue 官网 6 ember 17,956+ 129.89kb/v2.13.3 陡峭 全能框架、大量约定 官网 7 Riot.js 12,042+ 轻量级 官网 8 knockout.js 可学习,不推荐使用 8,249+ 适中 MVVM 官网,兼容IE9, 4.2 模板引擎技术 ejs Javascript模板–官网 jade js+html模板—–官网 blade php 模板——–官网 Smarty php 模板——–官网 thymeleaf JAVA模板——–官网 各路模板比拼： 4.2 css及icon类库 css样式兼容性测试，传送门 序号 名称 类别 说明 相关信息 1 sass 样式文件、CSS预处理器 官网、入门1、入门2 2 fontawesome 图标、样式库 50,716+ 官网、中文官网 3 iconfont 图标、样式库 阿里出品 官网 4 gliphyicon 图标、样式库 Author:Jan Kovarik 官网 4.3 动画类库 序号 名称 技术类型 Star指数 备注 说明 1 animate.css CSS (55.2kB) 42,557+ 63种纯CSS过度动画效果 案例 2 hover.css CSS 16,828+ 丰富的悬停效果amazing 案例 3 magic.css CSS (36.5kB) 4,915+ 丰富的渐变效果 案例 4 Dyncss.css CSS 386+ 页面滚动动画 案例 5 favico.js JavaScript 7,538+ 添加各种徽章效果 github 6 Textillate.js JavaScript 2,985+ 添加各种文字动画效果 案列,依赖:animate.css、lettering.js 7 bounce.js JavaScript 5,056+ 提供强大的弹性css动画 案例 8 Move.js JavaScript 4,042+ css动画 案例 9 AniJS.js JavaScript 3,087+ 事件动画效果 案例 … pace.js JavaScript 12,053+ 网页交互进度提示：ajax/http进度条 案例 4 可视化工具 序号 名称 团队 技术基础 star指数 备注 说明 1 D3.js 2 hightcharts 歪果仁 Javascript 官网 3 Chart.js google js+canvas +30,737 官网 4 Echarts2 百度 js +18,719 官网 5 G2 阿里—蚂蚁金服 js +592 官网、gihub G6/G2-mobile 简单粗暴的动车通道 5. Program tools Jquery ——前端入门级别插件库，主要用于调用DOM操作 英文官方网站链接，中文推荐非官方链接 Underscore ——函数式编程的功能集，提供一系列远超过map、filter、invoke等方法，涵盖函数绑定、js模板、创建索引，强类型测试等，英文官方网站链接 ，中文官方链接 moment.js ——JS时间处理插件，肥肠强大，英文官方网站链接， 中文官方链接 rxjs ——观察者模式，强大的函数式编程插件 入门介绍传送，英文官方网站链接，推荐非官方中文文档 mock.js ——一个模拟数据生成器，可以让前端独立于后端进行开发。主要功能：生成随机数据，拦截Ajax,适用场景：后端api未开发法完成，但数据格式已经确定。官网、Github alasql.js ——客户端数据库操作插件，用户web浏览器js内存中的数据库操作插件，可配合nodejs使用；官网、github star:+1910 lokijs ——客户端操作数据库插件，alasql.js替代插件，官网、github star +3，428: 6. SPA项目的SEO解决方案 目前spa页面的最大缺点莫过于搜索引擎的友好型很差，所以需要慎重考虑使用场景； SEO.js ：针对google搜索引擎,使单页面应用可被爬虫爬取的插件，官网 Fate :百度针对SPA的工具库 官网","raw":null,"content":null,"categories":[],"tags":[{"name":"文本","slug":"文本","permalink":"http://yoursite.com/tags/文本/"},{"name":"file","slug":"file","permalink":"http://yoursite.com/tags/file/"}]},{"title":"web 文件操作","slug":"ECMAScript5-API","date":"2017-09-09T05:19:33.000Z","updated":"2017-09-09T05:16:56.000Z","comments":true,"path":"2017/09/09/ECMAScript5-API/","link":"","permalink":"http://yoursite.com/2017/09/09/ECMAScript5-API/","excerpt":"","text":"1. Html5 二进制数据操作接口 Javascript中对二进制数据进行操作的API 1.str.charCodeAt(index):获取字符串str中某个字符的Unicode编码； 2.window.Blob：javascript中代表二进制数据的基本对象，html 5中新增对二进制数据进行处理API;一个Blob对象就是一个包含有只读原始数据的类文件对象。Blob对象中的数据并不一定得是JavaScript中的原生形式。File接口基于Blob，继承了Blob的功能,并且扩展支持了用户计算机上的本地文件，官方文档传送门; 2.charCodeAt()3.Blob对象","raw":null,"content":null,"categories":[],"tags":[{"name":"文本","slug":"文本","permalink":"http://yoursite.com/tags/文本/"},{"name":"file","slug":"file","permalink":"http://yoursite.com/tags/file/"}]},{"title":"Angular2 cli","slug":"angularCLI","date":"2017-09-09T05:18:33.000Z","updated":"2017-09-09T05:16:56.000Z","comments":true,"path":"2017/09/09/angularCLI/","link":"","permalink":"http://yoursite.com/2017/09/09/angularCLI/","excerpt":"","text":"相信不少同学已入坑angular,开始了angular2的慢慢长路，那么这些关于angular2项目自动化构建工具，你应该不会错过吧，Angular-cli 1.创建一个新项目 ng new project-name 创建一个新的项目,并自动安装依赖包,项目名称为：projec-name ng new project-name -si 创建一个新的项目，并跳过node依赖包自动安装（-si即--skip-install） 创建完成后项目的目录结构如下： 2.创建组件 ng g c component1 创建一个组件component1,同时创建相应的.html、.spc.ts、.css文件， ng g c component2 --is 创建一个组件component2,同时创建相应的.html、.spc.ts文件，采用内联式样式文件； ng g c component2/component3 --is -flat 创建一个组件component3,采用内联式样式; ng g c component2/component4 --is --it -flat创建一个组件component4,采用内联式样式、内联式模板; 如下图所示： ①ng g c component1②ng g c component2 --is (--is即-inline -style)③ng g c component2/component3 --is -flat -flat组件在当前文件夹下不新建目录④ng g c component2/component4 --is --it -flat (--it即：-inline -template) 3.创建模块 ng g m core-module 创建一个模块，模块名称 CoreModuleModule; ng g m module2 --routing 创建一个模块，模块名称 Module2Module,采用外联路由文件; 如下图： ①ng g m core-module②ng g m module2 --routing --routing 同时新建单独路由文件 4.创建类 ng g class class1 创建一个类，类名Class1 ng g class class2 --spec 创建一个类，类名Class2 如下图： ①ng g class class1②ng g class class2 --spec 同时创建.spec.ts文件 5.创建可枚举类 ng g enum enum1 创建一个可枚举类，类名Enum1 文件路径：app/enum1.enum.ts 如下图 ①ng g enum enum1","raw":null,"content":null,"categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"http://yoursite.com/tags/angular/"},{"name":"cli","slug":"cli","permalink":"http://yoursite.com/tags/cli/"}]},{"title":"Angular2 组件视图/样式封装机制","slug":"angular-view-Encapsulation","date":"2017-09-09T05:18:33.000Z","updated":"2017-09-09T05:14:44.000Z","comments":true,"path":"2017/09/09/angular-view-Encapsulation/","link":"","permalink":"http://yoursite.com/2017/09/09/angular-view-Encapsulation/","excerpt":"","text":"尽管css的意思是层叠样式表，但有时候我们并不需要”层叠”。既然angular采用了组件化的设计模式，那么我们能不能采用组件化的方式，为某个组件提供特定的局部（组件级别）个性样式而不影响到页面的其他部分，答案是肯定的。 1.标准html中样式的引入方式： 内嵌样式：直接在元素标签内设置css,如下栗子：&lt;div style=&quot;background-color:red&quot;&gt;内联样式&lt;/div&gt; 标签样式：采用style标签元素设定，如下栗子： 123&lt;style&gt; .nav-bar&#123;font-size:14px;&#125;&lt;/style&gt;` 链接引入样式: &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot;&gt; 导入样式: 123&lt;style&gt; @import url(../xx/style.css);&lt;/style&gt; 2.angular中样式引用方式： 全局样式引入 配置文件设置：.angular.cli.json文件中设置:`”apps”:{&quot;styles&quot;: [&quot;scss/style.scss&quot;], &quot;scripts&quot;:[...] }` 入口文件引入：index.html文件中：&lt;link href=&quot;assets/css/font-awesome.min.css&quot; rel=&quot;stylesheet&quot;&gt; 入口文件样式块：&lt;style&gt;.nav-bar{font-size:12px;}&lt;/style&gt; 组件级别引入： 组件内联：styles:&quot;.nav-bar{font-size:16px;} 组件外联：styleUrls:[&#39;./session.component.scss&#39;] 标签级别样式：&lt;div style=&quot;font-color:red&quot;&gt;&lt;/div&gt; 3. shadow DOM3.1：开发angular项目时，假如我们在配置文件.angular.cli.json、组件内联/外联、标签内，多处都设置了同样的样式，页面改如何展示？让我们先来预测一下结果：a.假如三处引入的样式都没有采用!important,那么根据优先级，页面的样式也就是标签内嵌样式的结果；b.假如三处引入的样式具有javascript模式的变量作用域概念，那么页面的样式应该是最小子组件覆盖父层组件样式；c.假如三处引入样式具有样式重写效果，那么，将按照样式的定义先后顺序，最后定义的样式覆盖先定义的样式； 令人兴奋的是，上面三种我们预测的效果，angular都有实现的技术：你所需要做的仅仅是在组件定义时加上一条元数据：encapsulation:ViewEncapsulation.Emulate/Native/None而这些神奇的功能效果，背后所支撑的技术就是目前组件化前端框架的基础：Shadow Dom. 3.2 Shadow DOM什么是shadow dom技术？简单来说，就是浏览器标准中开放给开发者用来自定义 html标签元素的API,接口也极其简单：Element.createShadowRoot(); Shadow DOM允许开发者在页面的DOM树结构里面，插入自定义的DOM元素子树，DOM元素子树的内容、页面样式、javascript均与宿主DOM树相互独立. 没错，这就是当今2017年前端最流行的组件化设计思想，得以实现的技术基础！！！刨根问底，请用力戳破==&gt;MDN文档、参考文章。 4. angular视图封装——————encapsulation:ViewEncapsulation.Emulate/Native/Native下面我们来依次看看angular是如何来实现这三个神奇的效果： Emulate：这是angular2默认配置方式，即：shadow DOM仿真方式，默认将组件样式、内容封装在组件的上下文环境中； Native: 即：原生Shadow DOM的配置方式，采用此种配置时，angular将完全采用MDN标准的Shadow DOM将子组件封装为子DOM树； None : 无Shadow DOM配置方式，采用此种配置时，angular2将完全不采用Shadow DOM技术，而是将子组件按照标准html方式渗透、暴露给页面其他元素； 为此我们看一下才用三种不同配置时，浏览器开发者模式下页面html代码的差异：创建一个最简单的angular项目；并在引入的全局样式文件style.scss、及app组件内联样式中分别定义一个.test的样式类目录结构如下为了便于区分，我们在全局样式定义前加上一行注释/* global styles */; ① 默认配置方式——Emulate，由于我们在app组件中并未定义ecapsulationmeata元素，此时为默认配置方式，打开浏览器，我们可以看到页面结构如下: 可以清楚的看到，我们在app组件中的页面元素div段落(红色方框3)，并且多出来一个_ngcontent-c0属性； 同时在head标签里面可以看到有两个style样式标签；两个style样式标签内都是对.test样式类进行定义； 所不同的是（方框1）为.test，方框2为.test[_ngcontent-c0],细心的同学可能已经发现， 这两个样式类，分别对应我们之前设置的全局scss样式及app组件级别的样式； 页面的div元素尺寸采用了全局的样式，而在app组件内部样式中，我们并没有设置尺寸相关的样式； 说明采用emulate配置方式，会继承全局的可继承的样式； 页面div元素的背景色和边框色都采用了app组件内部定义的样式，我们在全局及app组件内部两处都定义了背景色、边框的样式； 说明采用emulate配置方式，子组件会重写全局的样式； 结合上面三点，我们就不难理解，这个`_ngcontent-c0`的属性正是angular2为了识别封装的组件，自动添加的， 子组件可以继承并重写全局/父组件的演示，这就是angular的仿真Shadow DOM技术；* ② 原生配置方式——Shadow DOM,在app组件的装饰器内添加encapsulation:ViewEncapsulate.Native,再次运行项目，打开浏览器，如下： 此时，a.页面的内容元素没有变，但相比较①没有了属性_ngcontent-c0，同时在外层多了一个#shadow-root(open)的标签，这个正是标准的Shadow DOM技术； b.全局样式的标签位置和内容都没有变化（图中红色方框①）；c.app组件级别的样式不仅位置、样式类选择器都发生了变化：1）位置由head头部转移到 #shadow-root(opne)标签内部； 2）样式类没有添加_ngcontent-c0类似的angular框架属性； 此种原声shadow dom的配置方式，就是我们在本文第3节中提到的原生Shadow DOM； 此处div元素采用浏览器默认的尺寸样式，没有采用全局的尺寸样式；说明，此处子组件已无安全与福组件/全局样式隔离，不受全局样式影响； 此处div元素背景色、边框均采用子组件app设置的样式，说明此时，子组件可自由定义局部样式属性； ③ 无Shadow DOM配置方————在app组件的装饰器内添加encapsulation:ViewEncapsulate.None,再次运行项目，打开浏览器，如下： 此时页面元素的显示效果与仿真DOM方式的配置一模一样；html代码与仿真DOM配置方式下也极为相似；我们看一下与emulate配置方式的不同之处： app子组件中配置的.test类样式没有angular2自动添加的组件识别属性_ngcontent-c0； 这两天为了写这篇小博文，晚上花了一点时间，仔细想来，经典的技术/API很有可能给你打开一扇通向神奇的道路，现在前端如此火热的Shaodow DOM技术，其实在浏览器最初就已经成为标准了，我们常见的video就是这种技术实现的； 其实这种封装的思想在软件编程中已经是中所周知的思想了，但要真正运用到实际开发中，你才能真正的深入理解经典思想的精妙之处； ——————强行End","raw":null,"content":null,"categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"http://yoursite.com/tags/angular/"},{"name":"route","slug":"route","permalink":"http://yoursite.com/tags/route/"}]},{"title":"Angular2 导航方式","slug":"angular-router2","date":"2017-09-09T05:17:33.000Z","updated":"2017-09-09T05:14:44.000Z","comments":true,"path":"2017/09/09/angular-router2/","link":"","permalink":"http://yoursite.com/2017/09/09/angular-router2/","excerpt":"","text":"预警 1.导航方式 2.参数路由 1. 导航方式ngular2主要有两种导航方式： ①链接式导航：页面设置导航链接，点击后跳转至相应页面；如： 1&lt;a routerLink=['/home']&gt;click here to go to home page&lt;/a&gt; ②命令式导航：设置点击事件，在组件内进行逻辑页面跳转;如：12345678910111213@Component(&#123; template:` &lt;button (click)=\"goHome()\"&gt;主页面&lt;button&gt; //页面跳转事件 `, ...&#125;)export class AppComponent implements OnInit(&#123; constructor()&#123;&#125;; ngInit():void&#123;&#125; goDetail():void&#123; //跳转处理函数 this.router.navigate(['/home']); &#125;&#125;) 2. 路由传参导航加入我们现在有一个订单列表页面，需要查看每个订单的详情，改如何导航哪？a.我们可以为每个订单设置一个连接；b.设置路由跳转规则，导航是带上区别订单的关键字段；是的，没错，angular2就是采用方式2进行导航的； 在开始进行参数导航之前，让我们先来了看几个angular2的路由服务的相关术语： 序号 类别 部件 名称 作用 1 Route 路由 定义路由器如何根据URL模式来导航到组件，大多数都由路径和组件类构成 2 组件 Router 路由器 为激活的url显示对应的组件，负责从一个页面/组件，导航到另一个页面/组件 3 常量 Routes 路由数组 定义一个路由数组，每一个都会把一个URL路径映射到一个组件 4 模块 RouterModule 路由器模块 用于提供所需的服务提供商，提供进行导航的指令 5 指令 RouterLink 路由链接 [routerLink]=[&#39;str&#39;]用于把可点击的html元素绑定到路由 6 指令 RouterOutlet 路由插座 &lt;router-outlet&gt;用来标记路由该在哪里显示视图 7 指令 RouterLinkActive 活动的路由链接 当html元素上的routerLink变为激活或非激活状态时，该指令为相应元素添加或移除css类 8 方法 RouterState 路由器状态 路由器的当前状态包含了一颗由程序中激活的路由构成的树，，提供一些用于遍历路有数的快捷方法 9 服务 Activedroute 激活的路由 为每个路由组件提供一个服务，包含特定的路由信息，如：路由参数、静态数据、解析数据、全局查询参数、群居碎片","raw":null,"content":null,"categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"http://yoursite.com/tags/angular/"},{"name":"route","slug":"route","permalink":"http://yoursite.com/tags/route/"}]},{"title":"Angular   路由导航简介","slug":"angular-router1","date":"2017-09-09T05:16:33.000Z","updated":"2017-09-09T05:14:44.000Z","comments":true,"path":"2017/09/09/angular-router1/","link":"","permalink":"http://yoursite.com/2017/09/09/angular-router1/","excerpt":"","text":"剧情透露 1.浏览器默认路由 2.Angular2 路由及导航 1、浏览器路由模式 浏览器默认的导航模式主要有三种： ①点击页面链接，跳转至相应页面； ②输入url,点击确认，跳转至相应页面； ③点击浏览器前进后退箭头，进行页面的跳转； 关于浏览器url跳转原理，参靠这两篇：1.在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？2.输入网址之后发生的事。 2、Angular2 的路由导航以下内容默认读者对Angular2项目已有初步探索，熟悉angular2的项目目录结构： 1.概述Angular2默认采用支持html5浏览器的history.pushState进行导航，同时也支持老式的hash(#)风格导航；使用Angular2的路由功能简单来说分以下几个步骤： 导入路由模块Angular2的路由是一个可选的服务，并不包含在Angular核心库，在单独的@angular/router包中，需手动在src/app/app.module文件中导入，即： import{RouterModule,Routes} from &#39;@angular/router; 设置跟路由Angular路由默认采用相对文件路径，为了保证项目的正常导航，需要在根目录文件index.html中设置根路径；即：&lt;base href=&quot;/&quot;&gt; 路由文件配置至此，就可以尽情的享用angular的路由服务了？然而并未如此，你还要定义你的导航规则，也就要看到真正的导航效果，你还需要两步要走： ①设置路由配置：在src/app/app.module.ts文件中配置路由参数123456789101112131415161718 // 1.angular2 路由采用有限匹配原则，所以通用匹配一般放置在最后； // 2.angular2 路由配置文件中路径不能以斜杠slash('/')开头,导航时会自动识别转换； // 3.angular2 路由const appRoutes:Routes=[ &#123;path:'login',component:LoginComponent&#125;, //普通路由配置 &#123;path:'home',component:HomeComponent,data: &#123; title: 'home page' &#125;&#125;,//带页面说明信息路由配置 &#123;path:'pages/:id',component:PagesComponent&#125;, //带参数路由配置 &#123;path:'',redirectTo:'/home',pathMatch:'full'&#125;, //默认路由配置（路由重定向） &#123;path:'**',component:PageNotFoundComponent&#125; //无效路由配置（通配符）];@NgModule(&#123; imports:[ RouterModule.forRoot(appRoutes) //此处根模块使用 RouterModule.forRoot() //other imports here //若是子模块使用 RouterModule.forChild() ], ...&#125;)export class AppModule&#123;&#125; ②路由链接设置：至此我们只要在html页面中设置路由链接、组件视图渲染位置遍可以自由导航了； 1234567891011// 1. 路由链接：导航地址 routerLink=&apos;string&apos;// 当前导航是否可用 routerLinkActive=&apos;active&apos;// 2. 路由插座：组件视图渲染位置 &lt;router-outlet&gt;&lt;/router-outlet&gt;template:&apos; &lt;h1&gt;Angualr2 Router&lt;/h1&gt; &lt;nav&gt; &lt;a routerLink=&quot;/home&quot; routerLinkActive=&quot;active&quot;&gt;Home page&lt;/a&gt; &lt;a routerLink=&quot;/pages/:id&quot; routerLinkactive=&quot;active&quot;&gt;Detail page&lt;/a&gt; &lt;/nav&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt;&apos; PS:angular在导航是每个生命周期成功完成时，路由器会构建一个ActivedRoute组成的树，表示路由器的当前状态。我们可以在应用中的任何地方使用Router服务，以及routerState属性来访问当前RouterState值。","raw":null,"content":null,"categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"http://yoursite.com/tags/angular/"},{"name":"route","slug":"route","permalink":"http://yoursite.com/tags/route/"}]},{"title":"Angular  表单模块","slug":"angular-forms1","date":"2017-09-09T05:15:33.000Z","updated":"2017-09-09T05:13:56.000Z","comments":true,"path":"2017/09/09/angular-forms1/","link":"","permalink":"http://yoursite.com/2017/09/09/angular-forms1/","excerpt":"","text":"表单的作用 1.更新数据:同时更新页面、服务器端的数据； 2.在左右页面上更新输入后的数据； 3.对用户输入数据进行有效性验证； 4.信息提示：对用户输入进行引导，并在输入错误是给出提示信息 实现方式 1.Controls:控制器 2.","raw":null,"content":null,"categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"http://yoursite.com/tags/angular/"},{"name":"form","slug":"form","permalink":"http://yoursite.com/tags/form/"}]},{"title":"Angular 指令","slug":"angular-directive1","date":"2017-09-09T05:14:33.000Z","updated":"2017-09-09T05:13:37.000Z","comments":true,"path":"2017/09/09/angular-directive1/","link":"","permalink":"http://yoursite.com/2017/09/09/angular-directive1/","excerpt":"","text":"Angular的设计核心理念是数据绑定、组件化. 请时刻牢记这句话！ 按照惯例，先来剧情透露： angular指令种类 angular内置ngif指令 &lt;template&gt;标签 *ngIf语法糖 学习自定义一个指令 1.angular指令种类Angular的指令分为以下三种： 组件 属性指令 结构指令 ① 组件 Angular应用是由一个个的组件（component）构成的;组件是由html模板、组件类构成。html模板实现页面的展示内容，组件类用来控制视图的展示形式。每一个组件都以@Component装饰器函数开始，该函数接受一个元数据对象参数，这个元素苏描述了html模板与组件类如何协同工作的。 ②属性指令 属性指令用于改变元素的外观和行为。如内置的ngClass、ngStyle指令。 ③结构指令 结构指令通过添加或删除DOM元素来改变DOM布局。如内置的ngIf、ngSwitch、ngFor等指令。 下面我们主要针对ngIf来谈一下angular的一部分优缺点。 先看一个栗子：123456&lt;p *ngIf=&quot;true&quot;&gt;This information1 is displayed if condition is true.&lt;/p&gt;&lt;p *ngIf=&quot;!true&quot;&gt;Tihs information2 is deleted if condition is true.&lt;/p&gt; 打开浏览器及开发工具，效果如下; 我们看到dom树里面只有一个段落，也就是说第二个段落被*ngIf指令从DOM树种移除了，当然我们也可以通过设置元素节点css属性display:none将其隐藏。在彻底明白angular底层是如何实现这一功能的，我们还有必要来看看html的一个不常用标签元素&lt;template&gt;html5的template标签，允许开发者在里面添加一些代码段，这些代码段这页面初始化时不会被渲染，但可以被Javascript语句操作，并渲染在页面；下面是angular2, ngIf代码的两种使用方法：12345678&lt;!--(A)*语法糖 *ngIf paragraph--&gt;&lt;p *ngIf=&quot;condition&quot;&gt;This will show if condition is true.&lt;/p&gt;&lt;!--(B)template标签 [ngIf] with template--&gt;&lt;template [ngIf]=&quot;condition&quot;&gt; &lt;p&gt;This will show if condition is true.&lt;/p&gt;&lt;/template&gt;//ps.通常我们采用第一种书写方式（A）： angular内部会将风格(A)转换成(B) 为什么angular将其从DOM树种删除，而不是隐藏，我们先来看看两者之间的区别： ①元素隐藏：元素仍在页面DOM树里面存在，仍然实时监听着页面的事件，如果绑定了数据，angular会继续对其进行动态监测；②元素删除：元素彻底从页面DOM树消失，不会对页面的事件、数据及渲染造成任何影响； 我们之前说过，angular设计的核心理念之一便是数据绑定，就像官网所说： 最小化初始化的成本，并考虑把状态缓存在一个半生的服务中。 angular核心对数据进行自动检测；dom元素的操作、数据脏值检测，这两件事都是非常消耗cpu内存的，angular吸取了angular1数据绑定的负面经验，采用了第一种方案。无疑这对于数据动态监听来说效率提高了很多，但仍不能说这是一个最好的实践方法。作为一个开发者，在自定义新的指令时，我们同样面临着这种取舍，需要仔细考量添加元素、删除元素及销毁组件的成本和效率。","raw":null,"content":null,"categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"http://yoursite.com/tags/angular/"},{"name":"directive","slug":"directive","permalink":"http://yoursite.com/tags/directive/"}]},{"title":"angular component元数据","slug":"angular-component-class","date":"2017-06-09T05:13:33.000Z","updated":"2017-09-09T05:55:05.000Z","comments":true,"path":"2017/06/09/angular-component-class/","link":"","permalink":"http://yoursite.com/2017/06/09/angular-component-class/","excerpt":"","text":"序号 名称 类型 必要性 作用 示例 备注 1 template string 必须 组件内联html模板 2 templateUrl string 必须 组件外联html模板 3 styles strtin[] 非必须 组件内联css样式 4 styleUrls string[] 非必须 组件外联css样式 5 moduleId string 非必须 组件的组件id 7 encapsulation ViewEncapsulation 必须 组件的封装模式 8 viewProviders Provider[] 非必须 组件依赖注入的服务 9 animations any[] 非必须 组件级别的动画定义 10 interpolation [string,string] 非必须 11 entryComponents Array 非必须","raw":null,"content":null,"categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"http://yoursite.com/tags/angular/"},{"name":"component","slug":"component","permalink":"http://yoursite.com/tags/component/"}]}]}