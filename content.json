{"meta":{"title":"hbzyin-blog","subtitle":"Front end developer.","description":"web 前端 | 切图仔 | javascript | css | hbzyin","author":"hbzyin","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"由html的文档类型引发的ISO文档信息规范","slug":"html-doc-type","date":"2017-09-28T00:10:23.000Z","updated":"2017-09-30T07:50:15.000Z","comments":true,"path":"2017/09/28/html-doc-type/","link":"","permalink":"http://yoursite.com/2017/09/28/html-doc-type/","excerpt":" 作为一个前端开发者，HTML应该是最熟悉不过。打开电脑浏览器，点击鼠标右键，选择查看源码，所看到的就是html文本。那么文档类型定义声明有哪几种，各有什么作用，HTML、XML、SGML各是什么，DTD、DOCTYPE又是什么？","text":"作为一个前端开发者，HTML应该是最熟悉不过。打开电脑浏览器，点击鼠标右键，选择查看源码，所看到的就是html文本。那么文档类型定义声明有哪几种，各有什么作用，HTML、XML、SGML各是什么，DTD、DOCTYPE又是什么？ 1. 先来看两个简单的前端问题 1.HTML文档类型声明DCOTYPE的作用是什么？ &lt;!DOCTYPE&gt;声明位于html文档的第一行，位于&lt;html&gt;&lt;/html&gt;标签之前；&lt;!DOCTYPE&gt;声明不是html标签，是用于告诉web浏览器，解析页面采用哪个HTML版本进行编写的指令；&lt;!DOCTYPE&gt;声明对大小写不敏感； HTML4及更早版本基于SGML,&lt;!DOCTYPE&gt;声明引用 用于规定标记语言规则的DTD，使得浏览器能正确的显示内容；HTML5不基于SGML,不需要引用添加&lt;!DOCTYPE&gt;声明； 2.HTML文档类型声明有哪几种? 共8中=3种(html4.01)+3种(html1.0)+1种(html1.1)+1种(html5) HTML4.01文档类型声明有三种：①Strict(严格定义类型):该DTD仅允许使用HTML元素、属性；不允许使用展示性、弃用的元素(如:font)、不允许使用框架集(Frameset) 1&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt; ②Transitional(过渡定义类型):该DTD允许使用所有HTML元素、属性，允许是使用展示性、弃用的元素(如:font)；但不允许使用框架集(Frameset); 1&lt;!DOCTYOE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; ③Frameset(框架定义类型):该DTD允许使用HTM的所有元素、属性，允许使用展示性、弃用的元素，允许使用框架集(Frameset) 1&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot; &quot;HTTP://www.w3.org/TR/html4/frameset.dtd&quot;&gt; HTML1.0文档类型声明有四种类型：与html4.01不同的是，HTML1.0全部要求以正确的XML格式编写XML,即所有标签元素都必须封闭。①Strict(严格定义类型)：允许使用所有的HTML元素和属性；不允许使用展示性、弃用的元素、框架集； 1&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD/ XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt; ②Transitioal(过渡定义类型)：允许使用所有的HTML元素、属性，允许使用展示型、弃用的元素；但不允许使用框架集； 1&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD/ XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; ③Frameset(框架定义类型)：允许使用HTML元素、属性、展示性、弃用的元素、框架集； 1&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD/ XHTML 1.0 Frameset//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-Frameset.dtd&quot;&gt; HTML1.1文档类型声明仅有一种，与HTML1.0类似，但允许添加模型： 1&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD/ XHTML1.1//EN&quot; http://www.w3.org/TR/xhtml/DTD/xhtml11.dtd&quot;&gt; HTML5不基于SGML,其文档类型声明只有一种 1&lt;!DOCTYPE html&gt; 要建立符合标准的网页文档，浏览器能够识别HTML/XHTML文档的类型，并正确的进行识别、解析，html必须采用DOCTYPE声明；如果文档不定义DOCTYPE类型，浏览器按照自己的方式来进行解析渲染的过程可能就会出现差错导致无法正常解析，也就是混乱模式或怪异者模式。 2. SGML、HTML、XML ——标记语言 SGML:标准通用标记语言，即Standard Generalized Markup Language. 标准通用标记语言(SGML),是当今常用的超文本格式的最高层次标准，是一种跨平台、跨语言的一种可以定义标记语言的元语言，是IOS于1986年发布的一个信息管理方面的国际标准（ISO 8879:1986 Information processing -- Text and office systems -- Standard Generalized Markup Language (SGML)）;但由于其强大的适应性，及其复杂性，难以普及。HTML、XML都是SGML的一种派生。HTML是SGML的一个最成功的应用之一，而XML可以认为是SGML的一个子集；XML的产生便是为了简化SGML，以便于更加通用，比较成功的有语义Web、XHTML、RSS、XML-RPC、SOAP. HTML:超文本标记语言，即Hyper Text Markup Language. 超文本标记语言(HTML),衍生于SGML,是一种用于创建网页的标准标记语言。编写HTML文档时，需声明对文档类型进行声明，即本文开篇的两个问题。html与CSS、Javascript语言一起用于创建令人赏心悦目的网页、网页应用程序以及移动应用程序的用户界面。缺点是标记相对少(只有固定的标记)，缺少SGML的柔性和适应性，不能支持特定领域的标记语言。 XML：可扩展标记语言，即eXtensible Markup Language. 可扩展标记语言(XML)，是SGML的一种简化版本；表示一种结构化信息的标准文本格式；同HTML一样，编写XML文档前也需要进行文档类型声明，即XML序言,如&lt;?xml version=&quot;1.0&quot;?&gt;，会告诉解析器或浏览器，这个文件应该按照XML规则进行解析.XML语言的缺点是：不支持分帧(framing),当多条XML消息在TCP上传输时，无法基于XML协议来确定一条XML消息是否结束。 3. XML DTD 与XML Schema ——文档类型 VS 文档格式 首先插入两个概念 ①XML模式：指用来描述XML结构、约束因素的语言，如XML Schema、XML DTD、XDR、SOX等； ②XML格式：指XML文档本身所具有的格式； XML DTD: XML的文档类型定义的标准，采用与XML不同格式的语言，对XML文档的模式、格式进行规范描述的一种标准；缺点：XML DTD本身合法性缺少验证机制，需要与XML分开来进行合法性验证； XML Schema:XML的另一种文档类型定义标准，采用与XML相同格式的语言，对XML文档的模式、格式进行规范描述的一种标准； 参考文献 1.SGML–维基百科 2.XML Schema 与 XML DTD的技术比较与分析","raw":null,"content":null,"categories":[],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"},{"name":"DTD","slug":"DTD","permalink":"http://yoursite.com/tags/DTD/"},{"name":"XML","slug":"XML","permalink":"http://yoursite.com/tags/XML/"},{"name":"SGML","slug":"SGML","permalink":"http://yoursite.com/tags/SGML/"}]},{"title":"oAuth 认证机制","slug":"oAuth-md","date":"2017-09-09T07:31:39.000Z","updated":"2017-09-30T07:50:52.000Z","comments":true,"path":"2017/09/09/oAuth-md/","link":"","permalink":"http://yoursite.com/2017/09/09/oAuth-md/","excerpt":"\n 这段时间公司开发项目用到oAuth2协议，现在做一下梳理。\nCORS即Cross Origin Resouce Share，跨域资源共享；是W3C为防止脚本攻击，而制定的安全标准之一，它允许浏览器向跨域服务器发送XMLHttpRequest请求；跨域域问题，伴随而来的就是前端项目中的权限认证问题。\n","text":"这段时间公司开发项目用到oAuth2协议，现在做一下梳理。 CORS即Cross Origin Resouce Share，跨域资源共享；是W3C为防止脚本攻击，而制定的安全标准之一，它允许浏览器向跨域服务器发送XMLHttpRequest请求；跨域域问题，伴随而来的就是前端项目中的权限认证问题。 1. 基本逻辑： CORS跨域请求分为两种：简单请求、非简单请求，两种情景处理具体细节不同，但实现逻辑相同 简单请求需同时满足以下两个条件： 请求方法为：GET、HEAD、POST三种其中的一种； HTTP头信息不超出一下几个字段：①Accept ②Accept-Language ③Last-Event-ID ④Content ⑤Content-Type：只限三种：application/x-www-form-urlencoded、muiltipart/form-data、text/plain 简单请求流程：①浏览器检测到请求为跨域请求时，便在请求头上加上字段Origin，指明发出跨域请求的源；②服务器端检测到跨域请求头信息中，Origin是否在许可范围内：③若请求源在允许范围，返回响应，响应头上添加以下几个字段： 1234Access-Control-Allow-Origin:http://api.beta.com //服务器应许跨域白名单Access-Control-Allow-Credentials:true //允许跨域请求携带cookieAccess-Control-Expose-Headers:Custom-header //允许客户端请求时携带自定义头字段Conten-Type:text/html;chartset=utf-8 //允许返回数据类型 ④若跨域请求源不在允许范围内，服务器会返回一个XMLHttpRequest错误信息，该错误不能被http错误处理机制捕获，因为其状态码为200. 非简单请求： 非简单请求，通常是对服务器有特殊需求的请求， 非简单请求发送前，浏览器会自动发送一次预检请求，请求方法为Option 预检请求通过后，后续步骤同简单请求 oAuth2认证逻辑步骤 用户使用用户名、密码登录； 后台校验用户信息； 跳转至oAuth认证接口，返回token、refresh token、token expires;（此处token一般有有效期） 用户携带token值与后台DB服务通过http/https交互； token 值到期后；用户携带refresh token请求oAuth token刷新接口更新token并通过响应发送至客户； 重复第4、第5步，保证token有效可用状态下，与后台进行交互 oAuth2的协议.里面有两个比较常用的接口.1. 获取token接口: /oauth/token? 参数: (grant_type是写规定好的,其它的两个自定义) grant_type=password username=development@sometech.com password=oQd-BfT-cer-7LP 完整的样例:http://localhost:9000/oauth/token?grant_type=password&amp;username=development@sometech.com&amp;password=oQd-BfT-cer-7LP 返回结果样例: 1234567&#123; &quot;access_token&quot;: &quot;beeaa54e-8391-4de0-8ba6-ce145b3fb812&quot;, &quot;token_type&quot;: &quot;bearer&quot;, &quot;refresh_token&quot;: &quot;8129769a-d804-46c7-856a-3bacd409b650&quot;, &quot;expires_in&quot;: 3599, &quot;scope&quot;: &quot;read write&quot;&#125; 2. 刷新token接口:http://localhost:9000/oauth/token? 参数:(refresh_token是根据1中的来定的.其它参数是固定的) client_id=dashboard client_secret=secret grant_type=refresh_token refresh_token=43dca105-627e-4f50-86e8-0c22c2f3abe9 样例: http://localhost:9000/oauth/token?client_id=dashboard&amp;client_secret=secret&amp;grant_type=refresh_token&amp;refresh_token=43dca105-627e-4f50-86e8-0c22c2f3abe9 返回结果1234567&#123; &quot;access_token&quot;: &quot;0135c92b-12ab-4af9-88f4-97ef85115e71&quot;, &quot;token_type&quot;: &quot;bearer&quot;, &quot;refresh_token&quot;: &quot;75d209b5-a30d-43a8-abcd-850e7fb62e76&quot;, &quot;expires_in&quot;: 3599, &quot;scope&quot;: &quot;read write&quot;&#125; 3. CORS仅仅是实现跨域请求的一种，还有其他多种方案，如jsonp、document.domain、window.name、window.postMessage、CSST(css text Transformation)、flash等。 –end","raw":null,"content":null,"categories":[],"tags":[{"name":"secrect","slug":"secrect","permalink":"http://yoursite.com/tags/secrect/"}]},{"title":"workflow--项目工作流程","slug":"git-workflow","date":"2017-09-09T06:13:33.000Z","updated":"2017-09-30T07:52:38.000Z","comments":true,"path":"2017/09/09/git-workflow/","link":"","permalink":"http://yoursite.com/2017/09/09/git-workflow/","excerpt":"&emsp;&emsp;在软件开发的过程中，项目团队必然会使用版本控制系统，比如CVS、SVN(集中式版本控制系统)、GIT(分布式版本控制系统)。版本控制系统选定后，紧接着为了提高团队的协同开发效率，就需要选择一种适合当前团队、或者适合当前项目的开发流程。这里以主流的git版本控制系统为例，介绍常见的3种工作流：①Git flow ②Github flow ③Gitlab Flow","text":"&emsp;&emsp;在软件开发的过程中，项目团队必然会使用版本控制系统，比如CVS、SVN(集中式版本控制系统)、GIT(分布式版本控制系统)。版本控制系统选定后，紧接着为了提高团队的协同开发效率，就需要选择一种适合当前团队、或者适合当前项目的开发流程。这里以主流的git版本控制系统为例，介绍常见的3种工作流：①Git flow ②Github flow ③Gitlab Flow &emsp;&emsp;本文的三种工作流程，都属于功能驱动式开发(Featrue-driven development,简称FDD)范畴，FDD即项目开发的起点是需求，维护master主分支，切分出功能分支(feature branch)、补丁分支(hotfix branch);完成开发后，功能分支、补丁分支合并到主分支，同时被删除。 Git workflow 优点：流程清晰，版本清晰,理解简单 缺点：长期维护两个主分支，不便于持续发布；分支切换频繁 使用场景：定期发布，长期维护，如：游戏开发项目、底层服务程序 简介：维护2+3+个branch 长期维护2个分支master、develop分支 : master branch : 用于发布、生产部署，时刻保持最稳定生产版本，并标注版本号(Tag); develop branch : 用于日常开发维护，时刻存放最新开发版本，每次发开功能是从次分支拉出新的feature分支进行开发。 开发、发布维护3个临时分支，功能开发、部署完成之后便被删除 release branch : 用于正是发布前预发布，进行文档及版本元信息更新。合并到master分支完成正是发布后，便将该分支合更新并到develop分支，删除该分支； hotfix branch : 用于发布后紧急bug修复，或热修复，从master分支拉出。完成bug修复后便合并到master分支，同时将更新合并到develop分支，删除该分支； featureXXX branch : 用于新功能开发，当需要开发新功能时，从develop分支中拉出，用于开发新功能。开发完成后，便合并到develop分支并被删除； 3.Git workflow 具体工作流程图如下： Github workflow 优点：简单、适合频繁发布版本 缺点：版本概念模糊 使用场景：不定期持续发布、热发布，如：网站开发 简介：github.com 使用的工作流程、git flow精简版 长期维护1个分支； master branch : 用于发布、功能更新，时刻保持最新版本、稳定版本、随时可发布； 短期维护1+开发分支； featureXX branch : 用于开发新功能；从master分支拉出。功能开发完成后，向master分支发送pull request请求(简称PR)，合并请求被master branch允许后，该分支被删除； Github Flow工作流程示意图如下 Gitlab workflow 优点：兼容Git Flow 和Github Flow 两种模式 特点：上游优先 —— 只有上游分支采纳的版本变化，才会应用到其他分之； 简介： 持续发布模式 + 版本发布模式 持续发布模式 master branch : 开发环境分支，用于开发功能使用，是其他所有分支的上游分支。该分支更新的代码会向下应用到其他环境分支； pre-production branch : 预发环境分支，用于预发布测试，从master分支拉出，同时是production分支的上游。 production branch : 生产环境分支，用于生产发布，从pre-production分支拉出，是pre-production分支的下游。 featureX/fixX branch : 开发功能/修复bug分支，用于开发/修复bug,从master分支拉出，是master分支的上游。该分支开发完成后，先合并到mster分支，确认没有问题后；再cherry-pick到pre-production分支；pre-production分支也确认没有问题再cherry-pick到production分支。 版本发布模式 master branch : 开发环境分支，用于开发功能使用，是其他所有分支的上游分支。该分支更新的代码会向下应用到其他环境分支；Version-x branch : 发布版本分支，从master分支拉出，用于发布不同版本。featureX/fixX branch : 开发功能/修复bug分支，用于开发/修复bug,从master分支拉出，是master分支的上游。该分支开发完成后，先合并到mster分支，确认没有问题后；再cherry-pick到相对应的version-x分支。 两种工作模式的流程示意图 参考文章： 1.Git workflow 参考： git flow cheatsheet 、Git tower 2.Github workflow 参考：github guide 3.Gitlab workflow 参考：gitlab flow、gitlab workflow 4.版本控制系统入门介绍,参考： Subversion VS Git","raw":null,"content":null,"categories":[],"tags":[{"name":"workflow","slug":"workflow","permalink":"http://yoursite.com/tags/workflow/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"Ngx-bootstrap组件总结","slug":"web-component","date":"2017-09-09T05:20:33.000Z","updated":"2017-09-30T07:58:08.000Z","comments":true,"path":"2017/09/09/web-component/","link":"","permalink":"http://yoursite.com/2017/09/09/web-component/","excerpt":" 前端开发会有一些常见的需求，比如输入表单、日期、下拉菜单、表格、提示、弹窗等等，一般项目开发周期都被公司产品、市场等各种因素影响，被不断的压缩。除了极个别的开发大神，以及一些框架开发者，极少出现会自己去从零开始写这些常见的组件。","text":"前端开发会有一些常见的需求，比如输入表单、日期、下拉菜单、表格、提示、弹窗等等，一般项目开发周期都被公司产品、市场等各种因素影响，被不断的压缩。除了极个别的开发大神，以及一些框架开发者，极少出现会自己去从零开始写这些常见的组件。 而通常做法是引入一个成熟的插件/库来实现；Ngx-bootstrap便是可供选择的一个组件库，当然你也可以选择比如Prime-NG、material、material-ui等其他各种优秀的风格组件库，来做为你开发的工具。 本篇仅以ngx-bootstrap为例，介绍前端开发过程中一些常用的组件。 包括并不限于以下17种： 提示：tips——用于简短的缩写或特殊名词，用悬浮窗方式进行解释、备注。 弹窗：popover——点击后显示的隐藏导航、链接或注释。 消息条/警告：alerts——操作消息提示、或者系统消息列表提示。 模态框：modal——弹窗层对话框，一般用于有序步骤操作。 时间选择：timepicker——时间选择器，可针对具体到秒的时间选择，比如定时发送邮件等。 日期选择：datepicker——日期选择器，用于日期的选择，时间选择范围为年、月、日，可定制最大最小日期等。 下拉菜单：dropdowns——点击按钮弹出隐藏下拉菜单、导航或说明，菜单悬浮。 折叠面板：accordion——点击目标显示出隐藏内容，隐藏内容从属于文档流，会重新绘制dom; 标签页：tabs——点击标题菜单，切换不同的页面，用于分页显示同一类主题； 导航条：navBar——页面顶部或者侧边导航栏，用于页面主题内容的跳转控制、页面布局； 轮播图：carousel——图片轮播，一般用于多幅宣传图册的自动循环播放； 按钮：button——定制页面按钮的样式风格； 输入表单：imput——定制化页面的输入表单样式风格，用户可自定义； 表格：sortable——可排序内容，用于列表数据的排序用 分页：pagination——表格数据的分页展示控件，用于在优化页面展示效果，提升用户体验； 进度条:progressBar——一般用于数据加载、用户操作进度指示作用，提升用户页面交互体验； 具体效果图如下 carousel tips popover alertts modal timepicker datepicker pagination progressBar tabs rating –不定期更新中….","raw":null,"content":null,"categories":[],"tags":[{"name":"component","slug":"component","permalink":"http://yoursite.com/tags/component/"},{"name":"bootstrap","slug":"bootstrap","permalink":"http://yoursite.com/tags/bootstrap/"}]},{"title":"Front end","slug":"frontend-skills","date":"2017-09-09T05:20:33.000Z","updated":"2017-09-30T07:58:08.000Z","comments":true,"path":"2017/09/09/frontend-skills/","link":"","permalink":"http://yoursite.com/2017/09/09/frontend-skills/","excerpt":"本文为日常开发过程中遇到的各种工具及相关知识点的集合，作为日后开发的参考笔记之用","text":"本文为日常开发过程中遇到的各种工具及相关知识点的集合，作为日后开发的参考笔记之用 1. 设计模式相关 响应式/函数式编程：Rxjs-Reactive extention for javascript 面向对象式编程： OOP -Object Oriented Programming 迭代器模式编程： Iterator Pattern（ES6中可迭代对象：Array、String、Map、Set、DOM data structures） 2. Back-end 序号 范围 名称 作用 使用场景 相关信息 1 数据库 mySQL 后台数据库 暂无 官网 2 数据库 php 数据库脚本 官网 3 数据库 Nodejs 数据库脚本 事件驱动、非阻塞I/O模型 官网 2.1 后端框架 序号 名 称 所属语言 模板引擎 相关技术 1 Laravel php blade 2 SpringMVC JAVA thymeleaf 3 Express Nodejs jade、ejs、handlerbar 热部署工具PM2、Forever、strongloopPM 4 KOA Nodejs KOA 、Express、Hapi三大框架对比 3. 前端构建工具 序号 类别 名称 作用(范围) star 特点 官网 1 JS包管理器 npm JavaScript包管理器 13,284+ 官网 2 JS包管理器 yarn JavaScript包管理器 26,461+ 官网 3 前端项目打包压缩 webpack 所有资源 30,423+ 官网 4 前端项目打包压缩 gulp js、css、html 26,924+ 官网 5 前端项目打包压缩 grunt js、css、html 11,508+ 官网 6 前端项目打包压缩 bower js、css、html 15,171+ 官网 7 前端项目打包压缩 browserify js、css、html 11,201+ 官网 4. Front-end4.1 前端框架 不同框架性能对比测试，传送门 序号 名称 团队 设计模式 star 包大小(gzip) 学习曲线 相关技术 相关信息 1 angularjs 谷歌 双向数据绑定 56,105+ 陡峭 MVC 官网 2 angular 谷歌 双向数据绑定 26,225+ 237.41kb/v4.1.3 陡峭 MVC、组件化、Rxjs 官网 3 react facebook 单向数据绑定 71,926+ 46.45kb/v15.5.4 适中 MVC、组件化、React+Flux+JSX状态存储 官网 4 vue.js 尤雨溪（国内个人) 双向数据绑定 61,363+ 28.90kb/v2.3.4 简单 MVC、组件化、 官网 5 Polymer 谷歌赞助 17,815+ 129.89kb/v2.13.3 组件化，类似vue 官网 6 ember 17,956+ 129.89kb/v2.13.3 陡峭 全能框架、大量约定 官网 7 Riot.js 12,042+ 轻量级 官网 8 knockout.js 可学习,不推荐使用 8,249+ 适中 MVVM 官网,兼容IE9, 4.2 模板引擎技术 ejs Javascript模板–官网 jade js+html模板—–官网 blade php 模板——–官网 Smarty php 模板——–官网 thymeleaf JAVA模板——–官网 各路模板比拼： 4.2 css及icon类库 css样式兼容性测试，传送门 序号 名称 类别 说明 相关信息 1 sass 样式文件、CSS预处理器 官网、入门1、入门2 2 fontawesome 图标、样式库 50,716+ 官网、中文官网 3 iconfont 图标、样式库 阿里出品 官网 4 gliphyicon 图标、样式库 Author:Jan Kovarik 官网 4.3 动画类库 序号 名称 技术类型 Star指数 备注 说明 1 animate.css CSS (55.2kB) 42,557+ 63种纯CSS过度动画效果 案例 2 hover.css CSS 16,828+ 丰富的悬停效果amazing 案例 3 magic.css CSS (36.5kB) 4,915+ 丰富的渐变效果 案例 4 Dyncss.css CSS 386+ 页面滚动动画 案例 5 favico.js JavaScript 7,538+ 添加各种徽章效果 github 6 Textillate.js JavaScript 2,985+ 添加各种文字动画效果 案列,依赖:animate.css、lettering.js 7 bounce.js JavaScript 5,056+ 提供强大的弹性css动画 案例 8 Move.js JavaScript 4,042+ css动画 案例 9 AniJS.js JavaScript 3,087+ 事件动画效果 案例 … pace.js JavaScript 12,053+ 网页交互进度提示：ajax/http进度条 案例 4 可视化工具 序号 名称 团队 技术基础 star指数 备注 说明 1 D3.js 2 hightcharts 歪果仁 Javascript 官网 3 Chart.js google js+canvas +30,737 官网 4 Echarts2 百度 js +18,719 官网 5 G2 阿里—蚂蚁金服 js +592 官网、gihub G6/G2-mobile 简单粗暴的动车通道 5. Program tools Jquery ——前端入门级别插件库，主要用于调用DOM操作 英文官方网站链接，中文推荐非官方链接 Underscore ——函数式编程的功能集，提供一系列远超过map、filter、invoke等方法，涵盖函数绑定、js模板、创建索引，强类型测试等，英文官方网站链接 ，中文官方链接 moment.js ——JS时间处理插件，肥肠强大，英文官方网站链接， 中文官方链接 rxjs ——观察者模式，强大的函数式编程插件 入门介绍传送，英文官方网站链接，推荐非官方中文文档 mock.js ——一个模拟数据生成器，可以让前端独立于后端进行开发。主要功能：生成随机数据，拦截Ajax,适用场景：后端api未开发法完成，但数据格式已经确定。官网、Github alasql.js ——客户端数据库操作插件，用户web浏览器js内存中的数据库操作插件，可配合nodejs使用；官网、github star:+1910 lokijs ——客户端操作数据库插件，alasql.js替代插件，官网、github star +3，428: 6. SPA项目的SEO解决方案 目前spa页面的最大缺点莫过于搜索引擎的友好型很差，所以需要慎重考虑使用场景； SEO.js ：针对google搜索引擎,使单页面应用可被爬虫爬取的插件，官网 Fate :百度针对SPA的工具库 官网","raw":null,"content":null,"categories":[],"tags":[{"name":"文本","slug":"文本","permalink":"http://yoursite.com/tags/文本/"},{"name":"file","slug":"file","permalink":"http://yoursite.com/tags/file/"}]},{"title":"web 文件操作","slug":"ECMAScript5-API","date":"2017-09-09T05:19:33.000Z","updated":"2017-09-30T07:56:24.000Z","comments":true,"path":"2017/09/09/ECMAScript5-API/","link":"","permalink":"http://yoursite.com/2017/09/09/ECMAScript5-API/","excerpt":"二进制数据在在网络传输中是最常见的数据格式之一，对于前端开发二进制数据流，又如何运用处理那？","text":"二进制数据在在网络传输中是最常见的数据格式之一，对于前端开发二进制数据流，又如何运用处理那？ 1. Html5 二进制数据操作接口 Javascript中对二进制数据进行操作的API 1.str.charCodeAt(index):获取字符串str中某个字符的Unicode编码； 2.window.Blob：javascript中代表二进制数据的基本对象，html 5中新增对二进制数据进行处理API;一个Blob对象就是一个包含有只读原始数据的类文件对象。Blob对象中的数据并不一定得是JavaScript中的原生形式。File接口基于Blob，继承了Blob的功能,并且扩展支持了用户计算机上的本地文件，官方文档传送门; 2.charCodeAt()3.Blob对象","raw":null,"content":null,"categories":[],"tags":[{"name":"文本","slug":"文本","permalink":"http://yoursite.com/tags/文本/"},{"name":"file","slug":"file","permalink":"http://yoursite.com/tags/file/"}]},{"title":"Angular2 cli","slug":"angularCLI","date":"2017-09-09T05:18:33.000Z","updated":"2017-09-30T07:56:24.000Z","comments":true,"path":"2017/09/09/angularCLI/","link":"","permalink":"http://yoursite.com/2017/09/09/angularCLI/","excerpt":"相信不少同学已入坑angular,开始了angular2的慢慢长路，那么这些关于angular2项目自动化构建工具，你应该不会错过吧，Angular-cli","text":"相信不少同学已入坑angular,开始了angular2的慢慢长路，那么这些关于angular2项目自动化构建工具，你应该不会错过吧，Angular-cli 1.创建一个新项目 ng new project-name 创建一个新的项目,并自动安装依赖包,项目名称为：projec-name ng new project-name -si 创建一个新的项目，并跳过node依赖包自动安装（-si即--skip-install） 创建完成后项目的目录结构如下： 2.创建组件 ng g c component1 创建一个组件component1,同时创建相应的.html、.spc.ts、.css文件， ng g c component2 --is 创建一个组件component2,同时创建相应的.html、.spc.ts文件，采用内联式样式文件； ng g c component2/component3 --is -flat 创建一个组件component3,采用内联式样式; ng g c component2/component4 --is --it -flat创建一个组件component4,采用内联式样式、内联式模板; 如下图所示： ①ng g c component1②ng g c component2 --is (--is即-inline -style)③ng g c component2/component3 --is -flat -flat组件在当前文件夹下不新建目录④ng g c component2/component4 --is --it -flat (--it即：-inline -template) 3.创建模块 ng g m core-module 创建一个模块，模块名称 CoreModuleModule; ng g m module2 --routing 创建一个模块，模块名称 Module2Module,采用外联路由文件; 如下图： ①ng g m core-module②ng g m module2 --routing --routing 同时新建单独路由文件 4.创建类 ng g class class1 创建一个类，类名Class1 ng g class class2 --spec 创建一个类，类名Class2 如下图： ①ng g class class1②ng g class class2 --spec 同时创建.spec.ts文件 5.创建可枚举类 ng g enum enum1 创建一个可枚举类，类名Enum1 文件路径：app/enum1.enum.ts 如下图 ①ng g enum enum1","raw":null,"content":null,"categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"http://yoursite.com/tags/angular/"},{"name":"cli","slug":"cli","permalink":"http://yoursite.com/tags/cli/"}]},{"title":"Angular2 组件视图/样式封装机制","slug":"angular-view-Encapsulation","date":"2017-09-09T05:18:33.000Z","updated":"2017-09-30T07:56:24.000Z","comments":true,"path":"2017/09/09/angular-view-Encapsulation/","link":"","permalink":"http://yoursite.com/2017/09/09/angular-view-Encapsulation/","excerpt":"\n尽管css的意思是层叠样式表，但有时候我们并不需要”层叠”。既然angular采用了组件化的设计模式，那么我们能不能采用组件化的方式，为某个组件提供特定的局部（组件级别）个性样式而不影响到页面的其他部分，答案是肯定的。\n","text":"尽管css的意思是层叠样式表，但有时候我们并不需要”层叠”。既然angular采用了组件化的设计模式，那么我们能不能采用组件化的方式，为某个组件提供特定的局部（组件级别）个性样式而不影响到页面的其他部分，答案是肯定的。 1.标准html中样式的引入方式： 内嵌样式：直接在元素标签内设置css,如下栗子：&lt;div style=&quot;background-color:red&quot;&gt;内联样式&lt;/div&gt; 标签样式：采用style标签元素设定，如下栗子： 123&lt;style&gt; .nav-bar&#123;font-size:14px;&#125;&lt;/style&gt;` 链接引入样式: &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot;&gt; 导入样式: 123&lt;style&gt; @import url(../xx/style.css);&lt;/style&gt; 2.angular中样式引用方式： 全局样式引入 配置文件设置：.angular.cli.json文件中设置:`”apps”:{&quot;styles&quot;: [&quot;scss/style.scss&quot;], &quot;scripts&quot;:[...] }` 入口文件引入：index.html文件中：&lt;link href=&quot;assets/css/font-awesome.min.css&quot; rel=&quot;stylesheet&quot;&gt; 入口文件样式块：&lt;style&gt;.nav-bar{font-size:12px;}&lt;/style&gt; 组件级别引入： 组件内联：styles:&quot;.nav-bar{font-size:16px;} 组件外联：styleUrls:[&#39;./session.component.scss&#39;] 标签级别样式：&lt;div style=&quot;font-color:red&quot;&gt;&lt;/div&gt; 3. shadow DOM3.1：开发angular项目时，假如我们在配置文件.angular.cli.json、组件内联/外联、标签内，多处都设置了同样的样式，页面改如何展示？让我们先来预测一下结果：a.假如三处引入的样式都没有采用!important,那么根据优先级，页面的样式也就是标签内嵌样式的结果；b.假如三处引入的样式具有javascript模式的变量作用域概念，那么页面的样式应该是最小子组件覆盖父层组件样式；c.假如三处引入样式具有样式重写效果，那么，将按照样式的定义先后顺序，最后定义的样式覆盖先定义的样式； 令人兴奋的是，上面三种我们预测的效果，angular都有实现的技术：你所需要做的仅仅是在组件定义时加上一条元数据：encapsulation:ViewEncapsulation.Emulate/Native/None而这些神奇的功能效果，背后所支撑的技术就是目前组件化前端框架的基础：Shadow Dom. 3.2 Shadow DOM什么是shadow dom技术？简单来说，就是浏览器标准中开放给开发者用来自定义 html标签元素的API,接口也极其简单：Element.createShadowRoot(); Shadow DOM允许开发者在页面的DOM树结构里面，插入自定义的DOM元素子树，DOM元素子树的内容、页面样式、javascript均与宿主DOM树相互独立. 没错，这就是当今2017年前端最流行的组件化设计思想，得以实现的技术基础！！！刨根问底，请用力戳破==&gt;MDN文档、参考文章。 4. angular视图封装——————encapsulation:ViewEncapsulation.Emulate/Native/Native下面我们来依次看看angular是如何来实现这三个神奇的效果： Emulate：这是angular2默认配置方式，即：shadow DOM仿真方式，默认将组件样式、内容封装在组件的上下文环境中； Native: 即：原生Shadow DOM的配置方式，采用此种配置时，angular将完全采用MDN标准的Shadow DOM将子组件封装为子DOM树； None : 无Shadow DOM配置方式，采用此种配置时，angular2将完全不采用Shadow DOM技术，而是将子组件按照标准html方式渗透、暴露给页面其他元素； 为此我们看一下才用三种不同配置时，浏览器开发者模式下页面html代码的差异：创建一个最简单的angular项目；并在引入的全局样式文件style.scss、及app组件内联样式中分别定义一个.test的样式类目录结构如下为了便于区分，我们在全局样式定义前加上一行注释/* global styles */; ① 默认配置方式——Emulate，由于我们在app组件中并未定义ecapsulationmeata元素，此时为默认配置方式，打开浏览器，我们可以看到页面结构如下: 可以清楚的看到，我们在app组件中的页面元素div段落(红色方框3)，并且多出来一个_ngcontent-c0属性； 同时在head标签里面可以看到有两个style样式标签；两个style样式标签内都是对.test样式类进行定义； 所不同的是（方框1）为.test，方框2为.test[_ngcontent-c0],细心的同学可能已经发现， 这两个样式类，分别对应我们之前设置的全局scss样式及app组件级别的样式； 页面的div元素尺寸采用了全局的样式，而在app组件内部样式中，我们并没有设置尺寸相关的样式； 说明采用emulate配置方式，会继承全局的可继承的样式； 页面div元素的背景色和边框色都采用了app组件内部定义的样式，我们在全局及app组件内部两处都定义了背景色、边框的样式； 说明采用emulate配置方式，子组件会重写全局的样式； 结合上面三点，我们就不难理解，这个`_ngcontent-c0`的属性正是angular2为了识别封装的组件，自动添加的， 子组件可以继承并重写全局/父组件的演示，这就是angular的仿真Shadow DOM技术；* ② 原生配置方式——Shadow DOM,在app组件的装饰器内添加encapsulation:ViewEncapsulate.Native,再次运行项目，打开浏览器，如下： 此时，a.页面的内容元素没有变，但相比较①没有了属性_ngcontent-c0，同时在外层多了一个#shadow-root(open)的标签，这个正是标准的Shadow DOM技术； b.全局样式的标签位置和内容都没有变化（图中红色方框①）；c.app组件级别的样式不仅位置、样式类选择器都发生了变化：1）位置由head头部转移到 #shadow-root(opne)标签内部； 2）样式类没有添加_ngcontent-c0类似的angular框架属性； 此种原声shadow dom的配置方式，就是我们在本文第3节中提到的原生Shadow DOM； 此处div元素采用浏览器默认的尺寸样式，没有采用全局的尺寸样式；说明，此处子组件已无安全与福组件/全局样式隔离，不受全局样式影响； 此处div元素背景色、边框均采用子组件app设置的样式，说明此时，子组件可自由定义局部样式属性； ③ 无Shadow DOM配置方————在app组件的装饰器内添加encapsulation:ViewEncapsulate.None,再次运行项目，打开浏览器，如下： 此时页面元素的显示效果与仿真DOM方式的配置一模一样；html代码与仿真DOM配置方式下也极为相似；我们看一下与emulate配置方式的不同之处： app子组件中配置的.test类样式没有angular2自动添加的组件识别属性_ngcontent-c0； 这两天为了写这篇小博文，晚上花了一点时间，仔细想来，经典的技术/API很有可能给你打开一扇通向神奇的道路，现在前端如此火热的Shaodow DOM技术，其实在浏览器最初就已经成为标准了，我们常见的video就是这种技术实现的； 其实这种封装的思想在软件编程中已经是中所周知的思想了，但要真正运用到实际开发中，你才能真正的深入理解经典思想的精妙之处； ——————强行End","raw":null,"content":null,"categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"http://yoursite.com/tags/angular/"},{"name":"route","slug":"route","permalink":"http://yoursite.com/tags/route/"}]},{"title":"Angular2 导航方式","slug":"angular-router2","date":"2017-09-09T05:17:33.000Z","updated":"2017-09-30T07:54:52.000Z","comments":true,"path":"2017/09/09/angular-router2/","link":"","permalink":"http://yoursite.com/2017/09/09/angular-router2/","excerpt":"预警\n1.导航方式：angular的路由导航有那些方式，各自如何实现\n2.参数路由：angular路由导航时候如何携带参数\n","text":"预警 1.导航方式：angular的路由导航有那些方式，各自如何实现 2.参数路由：angular路由导航时候如何携带参数 1. 导航方式ngular2主要有两种导航方式： ①链接式导航：页面设置导航链接，点击后跳转至相应页面；如： 1&lt;a routerLink=['/home']&gt;click here to go to home page&lt;/a&gt; ②命令式导航：设置点击事件，在组件内进行逻辑页面跳转;如：12345678910111213@Component(&#123; template:` &lt;button (click)=\"goHome()\"&gt;主页面&lt;button&gt; //页面跳转事件 `, ...&#125;)export class AppComponent implements OnInit(&#123; constructor()&#123;&#125;; ngInit():void&#123;&#125; goDetail():void&#123; //跳转处理函数 this.router.navigate(['/home']); &#125;&#125;) 2. 路由传参导航加入我们现在有一个订单列表页面，需要查看每个订单的详情，改如何导航哪？a.我们可以为每个订单设置一个连接；b.设置路由跳转规则，导航是带上区别订单的关键字段；是的，没错，angular2就是采用方式2进行导航的； 在开始进行参数导航之前，让我们先来了看几个angular2的路由服务的相关术语： 序号 类别 部件 名称 作用 1 Route 路由 定义路由器如何根据URL模式来导航到组件，大多数都由路径和组件类构成 2 组件 Router 路由器 为激活的url显示对应的组件，负责从一个页面/组件，导航到另一个页面/组件 3 常量 Routes 路由数组 定义一个路由数组，每一个都会把一个URL路径映射到一个组件 4 模块 RouterModule 路由器模块 用于提供所需的服务提供商，提供进行导航的指令 5 指令 RouterLink 路由链接 [routerLink]=[&#39;str&#39;]用于把可点击的html元素绑定到路由 6 指令 RouterOutlet 路由插座 &lt;router-outlet&gt;用来标记路由该在哪里显示视图 7 指令 RouterLinkActive 活动的路由链接 当html元素上的routerLink变为激活或非激活状态时，该指令为相应元素添加或移除css类 8 方法 RouterState 路由器状态 路由器的当前状态包含了一颗由程序中激活的路由构成的树，，提供一些用于遍历路有数的快捷方法 9 服务 Activedroute 激活的路由 为每个路由组件提供一个服务，包含特定的路由信息，如：路由参数、静态数据、解析数据、全局查询参数、群居碎片","raw":null,"content":null,"categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"http://yoursite.com/tags/angular/"},{"name":"route","slug":"route","permalink":"http://yoursite.com/tags/route/"}]},{"title":"Angular   路由导航简介","slug":"angular-router1","date":"2017-09-09T05:16:33.000Z","updated":"2017-09-30T07:53:46.000Z","comments":true,"path":"2017/09/09/angular-router1/","link":"","permalink":"http://yoursite.com/2017/09/09/angular-router1/","excerpt":"剧情透露\n1.浏览器默认路由\n2.Angular2 路由及导航\n\n1、浏览器路由模式  浏览器默认的导航模式主要有三种：\n\n①点击页面链接，跳转至相应页面；\n②输入url,点击确认，跳转至相应页面；\n③点击浏览器前进后退箭头，进行页面的跳转；\n","text":"剧情透露 1.浏览器默认路由 2.Angular2 路由及导航 1、浏览器路由模式 浏览器默认的导航模式主要有三种： ①点击页面链接，跳转至相应页面； ②输入url,点击确认，跳转至相应页面； ③点击浏览器前进后退箭头，进行页面的跳转； 关于浏览器url跳转原理，参靠这两篇：1.在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？2.输入网址之后发生的事。 2、Angular2 的路由导航以下内容默认读者对Angular2项目已有初步探索，熟悉angular2的项目目录结构： 1.概述Angular2默认采用支持html5浏览器的history.pushState进行导航，同时也支持老式的hash(#)风格导航；使用Angular2的路由功能简单来说分以下几个步骤： 导入路由模块Angular2的路由是一个可选的服务，并不包含在Angular核心库，在单独的@angular/router包中，需手动在src/app/app.module文件中导入，即： import{RouterModule,Routes} from &#39;@angular/router; 设置跟路由Angular路由默认采用相对文件路径，为了保证项目的正常导航，需要在根目录文件index.html中设置根路径；即：&lt;base href=&quot;/&quot;&gt; 路由文件配置至此，就可以尽情的享用angular的路由服务了？然而并未如此，你还要定义你的导航规则，也就要看到真正的导航效果，你还需要两步要走： ①设置路由配置：在src/app/app.module.ts文件中配置路由参数123456789101112131415161718 // 1.angular2 路由采用有限匹配原则，所以通用匹配一般放置在最后； // 2.angular2 路由配置文件中路径不能以斜杠slash('/')开头,导航时会自动识别转换； // 3.angular2 路由const appRoutes:Routes=[ &#123;path:'login',component:LoginComponent&#125;, //普通路由配置 &#123;path:'home',component:HomeComponent,data: &#123; title: 'home page' &#125;&#125;,//带页面说明信息路由配置 &#123;path:'pages/:id',component:PagesComponent&#125;, //带参数路由配置 &#123;path:'',redirectTo:'/home',pathMatch:'full'&#125;, //默认路由配置（路由重定向） &#123;path:'**',component:PageNotFoundComponent&#125; //无效路由配置（通配符）];@NgModule(&#123; imports:[ RouterModule.forRoot(appRoutes) //此处根模块使用 RouterModule.forRoot() //other imports here //若是子模块使用 RouterModule.forChild() ], ...&#125;)export class AppModule&#123;&#125; ②路由链接设置：至此我们只要在html页面中设置路由链接、组件视图渲染位置遍可以自由导航了； 1234567891011// 1. 路由链接：导航地址 routerLink=&apos;string&apos;// 当前导航是否可用 routerLinkActive=&apos;active&apos;// 2. 路由插座：组件视图渲染位置 &lt;router-outlet&gt;&lt;/router-outlet&gt;template:&apos; &lt;h1&gt;Angualr2 Router&lt;/h1&gt; &lt;nav&gt; &lt;a routerLink=&quot;/home&quot; routerLinkActive=&quot;active&quot;&gt;Home page&lt;/a&gt; &lt;a routerLink=&quot;/pages/:id&quot; routerLinkactive=&quot;active&quot;&gt;Detail page&lt;/a&gt; &lt;/nav&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt;&apos; PS:angular在导航是每个生命周期成功完成时，路由器会构建一个ActivedRoute组成的树，表示路由器的当前状态。我们可以在应用中的任何地方使用Router服务，以及routerState属性来访问当前RouterState值。","raw":null,"content":null,"categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"http://yoursite.com/tags/angular/"},{"name":"route","slug":"route","permalink":"http://yoursite.com/tags/route/"}]},{"title":"Angular  表单模块","slug":"angular-forms1","date":"2017-09-09T05:15:33.000Z","updated":"2017-09-30T07:53:46.000Z","comments":true,"path":"2017/09/09/angular-forms1/","link":"","permalink":"http://yoursite.com/2017/09/09/angular-forms1/","excerpt":"表单的作用\n1.更新数据:同时更新页面、服务器端的数据；\n2.在左右页面上更新输入后的数据；\n3.对用户输入数据进行有效性验证；\n4.信息提示：对用户输入进行引导，并在输入错误是给出提示信息","text":"表单的作用 1.更新数据:同时更新页面、服务器端的数据； 2.在左右页面上更新输入后的数据； 3.对用户输入数据进行有效性验证； 4.信息提示：对用户输入进行引导，并在输入错误是给出提示信息 实现方式 1.Controls:控制器 2.","raw":null,"content":null,"categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"http://yoursite.com/tags/angular/"},{"name":"form","slug":"form","permalink":"http://yoursite.com/tags/form/"}]},{"title":"Angular 指令","slug":"angular-directive1","date":"2017-09-09T05:14:33.000Z","updated":"2017-09-30T07:53:24.000Z","comments":true,"path":"2017/09/09/angular-directive1/","link":"","permalink":"http://yoursite.com/2017/09/09/angular-directive1/","excerpt":"Angular的设计核心理念是数据绑定、组件化. 请时刻牢记这句话！\n按照惯例，先来剧情透露：\n\nangular指令种类\nangular内置ngif指令\n&lt;template&gt;标签\n*ngIf语法糖\n学习自定义一个指令\n","text":"Angular的设计核心理念是数据绑定、组件化. 请时刻牢记这句话！ 按照惯例，先来剧情透露： angular指令种类 angular内置ngif指令 &lt;template&gt;标签 *ngIf语法糖 学习自定义一个指令 1.angular指令种类Angular的指令分为以下三种： 组件 属性指令 结构指令 ① 组件 Angular应用是由一个个的组件（component）构成的;组件是由html模板、组件类构成。html模板实现页面的展示内容，组件类用来控制视图的展示形式。每一个组件都以@Component装饰器函数开始，该函数接受一个元数据对象参数，这个元素苏描述了html模板与组件类如何协同工作的。 ②属性指令 属性指令用于改变元素的外观和行为。如内置的ngClass、ngStyle指令。 ③结构指令 结构指令通过添加或删除DOM元素来改变DOM布局。如内置的ngIf、ngSwitch、ngFor等指令。 下面我们主要针对ngIf来谈一下angular的一部分优缺点。 先看一个栗子：123456&lt;p *ngIf=&quot;true&quot;&gt;This information1 is displayed if condition is true.&lt;/p&gt;&lt;p *ngIf=&quot;!true&quot;&gt;Tihs information2 is deleted if condition is true.&lt;/p&gt; 打开浏览器及开发工具，效果如下; 我们看到dom树里面只有一个段落，也就是说第二个段落被*ngIf指令从DOM树种移除了，当然我们也可以通过设置元素节点css属性display:none将其隐藏。在彻底明白angular底层是如何实现这一功能的，我们还有必要来看看html的一个不常用标签元素&lt;template&gt;html5的template标签，允许开发者在里面添加一些代码段，这些代码段这页面初始化时不会被渲染，但可以被Javascript语句操作，并渲染在页面；下面是angular2, ngIf代码的两种使用方法：12345678&lt;!--(A)*语法糖 *ngIf paragraph--&gt;&lt;p *ngIf=&quot;condition&quot;&gt;This will show if condition is true.&lt;/p&gt;&lt;!--(B)template标签 [ngIf] with template--&gt;&lt;template [ngIf]=&quot;condition&quot;&gt; &lt;p&gt;This will show if condition is true.&lt;/p&gt;&lt;/template&gt;//ps.通常我们采用第一种书写方式（A）： angular内部会将风格(A)转换成(B) 为什么angular将其从DOM树种删除，而不是隐藏，我们先来看看两者之间的区别： ①元素隐藏：元素仍在页面DOM树里面存在，仍然实时监听着页面的事件，如果绑定了数据，angular会继续对其进行动态监测；②元素删除：元素彻底从页面DOM树消失，不会对页面的事件、数据及渲染造成任何影响； 我们之前说过，angular设计的核心理念之一便是数据绑定，就像官网所说： 最小化初始化的成本，并考虑把状态缓存在一个半生的服务中。 angular核心对数据进行自动检测；dom元素的操作、数据脏值检测，这两件事都是非常消耗cpu内存的，angular吸取了angular1数据绑定的负面经验，采用了第一种方案。无疑这对于数据动态监听来说效率提高了很多，但仍不能说这是一个最好的实践方法。作为一个开发者，在自定义新的指令时，我们同样面临着这种取舍，需要仔细考量添加元素、删除元素及销毁组件的成本和效率。","raw":null,"content":null,"categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"http://yoursite.com/tags/angular/"},{"name":"directive","slug":"directive","permalink":"http://yoursite.com/tags/directive/"}]},{"title":"angular component元数据","slug":"angular-component-class","date":"2017-06-09T05:13:33.000Z","updated":"2017-09-30T07:53:13.000Z","comments":true,"path":"2017/06/09/angular-component-class/","link":"","permalink":"http://yoursite.com/2017/06/09/angular-component-class/","excerpt":"angular的核心概念知多少","text":"angular的核心概念知多少 序号 名称 类型 必要性 作用 示例 备注 1 template string 必须 组件内联html模板 2 templateUrl string 必须 组件外联html模板 3 styles strtin[] 非必须 组件内联css样式 4 styleUrls string[] 非必须 组件外联css样式 5 moduleId string 非必须 组件的组件id 7 encapsulation ViewEncapsulation 必须 组件的封装模式 8 viewProviders Provider[] 非必须 组件依赖注入的服务 9 animations any[] 非必须 组件级别的动画定义 10 interpolation [string,string] 非必须 11 entryComponents Array 非必须","raw":null,"content":null,"categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"http://yoursite.com/tags/angular/"},{"name":"component","slug":"component","permalink":"http://yoursite.com/tags/component/"}]}]}